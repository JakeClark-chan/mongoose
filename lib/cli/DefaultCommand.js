import { promises as fsp } from 'node:fs';
import * as path from 'node:path';
import { getConfig, provideCwd } from '@wesjet/core';
import { provideJaegerTracing, recRemoveUndefinedValues } from '@wesjet/utils';
import { OT, pipe, pretty, provideConsole, T } from '@wesjet/utils/effect';
import { NodeFsLive } from '@wesjet/utils/node';
import { Command, Option } from 'clipanion';
import * as t from 'typanion';
import { convertSchema } from './convert.js';
import { toYamlString } from './utils.js';
const defaultStackbitYamlPath = () => `${path.join(process.cwd())}/stackbit.yaml`;
const defaultTransformPath = () => `${path.join(process.cwd())}/stackbit-config-wesjet.js`;
export class DefaultCommand extends Command {
    constructor() {
        super(...arguments);
        this.configPath = Option.String('-c,--config', 'wesjet.config.ts', {
            description: 'Path to the Wesjet config',
            validator: t.isString(),
        });
        this.stackbitYamlPath = Option.String('-s,--stackbit', defaultStackbitYamlPath(), {
            description: 'Target path for Stackbit YAML file',
            validator: t.isString(),
        });
        this.transformPath = Option.String('-t,--transform', defaultTransformPath(), {
            description: 'Path to a "transform file" which allows you to transform the derived Stackbit config before generating the output file',
            validator: t.isString(),
        });
        this.executeSafe = () => pipe(getConfig({ configPath: this.configPath }), T.chain((config) => T.struct({
            source: T.succeed(config.source),
            schema: config.source.provideSchema(config.esbuildHash),
        })), T.chain(({ schema, source }) => T.tryCatchPromise(async () => {
            let stackbitConfig = convertSchema(schema, source.extensions);
            recRemoveUndefinedValues(stackbitConfig);
            const transform = await getTransform(this.transformPath);
            if (transform) {
                stackbitConfig = transform(stackbitConfig);
            }
            const yamlContent = `\
# This file is generated by Wesjet

${toYamlString(stackbitConfig)}
`;
            await fsp.writeFile(this.stackbitYamlPath, yamlContent);
            console.log(`Stackbit config generated to ${this.stackbitYamlPath}`);
        }, (error) => error)), OT.withSpan('DefaultCommand:executeSafe'));
    }
    // TODO refactor similar to `@wesjet/cli`
    async execute() {
        try {
            await pipe(this.executeSafe(), provideJaegerTracing('stackbit-config-wesjet'), T.tapCause((cause) => T.die(pretty(cause))), provideCwd, provideConsole, T.provideSomeLayer(NodeFsLive), T.runPromise);
        }
        catch (e) {
            console.error(e);
            throw e;
        }
    }
}
const getTransform = async (transformPath) => {
    const transformFileExists = await fileOrDirExists(transformPath);
    if (!transformFileExists) {
        return undefined;
    }
    const transform = require(transformPath);
    if (typeof transform !== 'function') {
        throw new Error(`Transform file "${transformPath}" doesn't export a function`);
    }
    return transform;
};
const fileOrDirExists = async (filePath) => {
    try {
        const stat = await fsp.stat(filePath);
        return stat.isFile() || stat.isDirectory();
    }
    catch (e) {
        return false;
    }
};
//# sourceMappingURL=DefaultCommand.js.map